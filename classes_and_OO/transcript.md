Course Overview
Course Overview
Hi everyone. I'm Robert Smallshire, and I'm Austin Bingham, and we're here to welcome you to our course, Core Python: Classes and Object‑oriented Programming. ‑We're both founders and principle consultants at Sixty North. ‑Python is, at its core, an object‑oriented language. It's no stretch to claim that everything in Python is an object, and in turn, every object is of a particular class. And in this course, you'll learn intermediate‑level techniques for creating, representing, combining, and manipulating classes in Python. ‑Some of the major topics we'll cover include defining per class rather than per object data and methods, using properties for graceful upgrade from plain attributes, how to represent your objects as strings for various types of user, method resolution and how this relates to multiple inheritance, transforming classes with class decorators, creating simple data classes. ‑By the end of this course, you'll know how to create idiomatic Python classes that work the way most experienced Python programmers expect, and you'll have a deeper appreciation of how Python classes can be used to encapsulate data and provide rich behaviors. ‑Before beginning this course, students should be familiar with the essentials of the Python language, including functions, classes, and modules. This course assumes knowledge of these topics, equivalent what's presented in Core Python: Getting Started and Core Python: Functions and Functional Programming. ‑We hope you'll join us on this journey to learn more about Python with the Core Python: Classes and Object‑oriented Programming course, at Pluralsight.

Class Attributes, Methods, and Properties
Overview
In this module, we're going to deepen your knowledge of classes in Python and the various kinds of attributes, methods, and other objects that classes can contain. We won't be introducing classes from scratch. For that, you should see our Core Python: Getting Started course where you will encounter simple classes with instance attributes and instance methods. In any case, we'll be starting with a quick review of classes, initializers, and instance attributes. We'll then move on to look at class attributes, static methods, and class methods before seeing how these features interact with inheritance. Next, we'll move on to improving the encapsulation of data within classes using properties before seeing how to specialize properties in the presence of inheritance. We'll finish off by introducing a particular design pattern useful for working with properties in Python. Before we go on, we need to take a quick aside regarding terminology. In Python, many language features are implemented or controlled using specially named objects and functions. These special names generally have two leading and two trailing underscores. This has the benefit of making them visually distinct, fairly easy to remember, and unlikely to collide with other names. This scheme has the disadvantage, however, of making these names difficult to pronounce, a problem we face when making courses like this. To resolve this issue, we've chosen to use the term dunder when pronouncing these names. Dunder is a portmanteau of the term double underscore, and we'll use it to refer to any name with leading and trailing double underscores. So, for example, when we talk about underscore underscore name underscore underscore, something you'll soon encounter, we'll say dunder name. These kinds of names play a big role in Python, so we'll be using this convention frequently. You should already be familiar with instance attributes. These are attributes which are assigned on a per object basis, usually in the dunder init method of a class. Throughout this part of the course, we'll be using an example based on modeling shipping containers. There is a long tradition of using the shipping of containers to illustrate object models. We'll start with a class that defines a simple shipping container. We'll put the code in a Python module called shipping.py. You can follow along while we develop this system in PyCharm. We'll start with a very basic class called ShippingContainer, which has a do nothing initializer, accepting only the self arguments for the instance and containing a pass statement. Our ShippingContainer class will initially carry two pieces of information, a code which signifies the owner of the shipping container, and contents, which will be a list of strings describing the contents of the container. In the Python repel, we can import everything from our shipping module and instantiate our simple ShippingContainer with the owner code for Yang Ming Line, YML, containing some books. We can report the owner code, YML, and the contents by accessing the instance attributes through the instance we have just created. If we create a second ShippingContainer instance, this new object has its own independent owner code and contents attributes, just as we would expect, which we can see when we access them through this second instance, As we said, instance attributes are per object, so each object has its own instance attributes.

Class Attributes
Sometimes we would like to have an attribute that is associated with the class and not with each instance of the class. In other words, we would like an attribute whose value is shared between all instances of that class. Such attributes are known as class attributes, and they can be created by assigning to their names within the body of the class. Let's say we'd like to give each ShippingContainer instance we create a new serial number. We can add next_serial in the class block. Starting at the arbitrary value of 1337, we've chosen to make our example more interesting. We also modify the initializer method to assign the current value of the next_serial class attribute to a new instance attribute, self.serial. On the last line of the initializer, we increment the next_serial class attribute. Let's try it in a new REPL session. From shipping, import everything. We'll create ShippingContainer c3 with the owner code MAE containing some tools. Oh, dear. As we can see, this didn't work as planned as we got an UnboundLocalError. This is because Python can't resolve the next_serial name where we first refer to it in the __init__ method. To understand why, we need to recall the Python rules for searching scopes, local, enclosing function, global, and built‑in, or LEGB. The only name defined at local scope in this function are self, owner_code, and contents. The class block doesn't count as an enclosing scope, so there is no enclosing scope here. As global scope, we have the class name ShippingContainer. Since next_serial doesn't exist in any of these scopes and classes don't introduce new scopes, we need to locate an object that is in one of these scopes and drill down to next_serial from there, in this case, the ShippingContainer class object. Is it global or module scope? So we must start from there by qualifying the next_serial class attribute name as ShippingContainer.next_serial. Let's go ahead and fix our class to fully qualify references to the class attribute. Now we have self.serial = ShippingContainer.next_serial and ShippingContainer.next_serial += 1. At first, it might look odd to have to refer to the class by name from within the class definition, but it's really not much different from having to qualify instance attributes with self. As with the self prefix, using the class name prefix for class attributes confers the same understandability advantage, reducing the amount of detective work required to figure out which objects are being referred to. Remember the Zen of Python, Explicit is better than implicit, and also Readability counts. With these changes in place, our example works as expected. ShippingContainer c4 containing electronics has serial number 1337. ShippingContainer c5 containing pharmaceuticals is given serial number 1338. And ShippingContained c6 is assigned serial number 1339. We can also retrieve the class attribute from outside the class by qualifying it with the class name, ShippingContainer.next_serial. Or we can access the same attribute through any of the instances, c5.next_serial or c6.next_serial. Returning to our code, this shows that we could have written our __init__ function like this, referencing the class attribute through the instance self, self.serial = self.next_serial. Although this works, this style is best avoided since it makes it much less clear within the function body which attributes are instance attributes and which are class attributes. There's another pitfall here of which you must be made aware. Although you can read a class attribute through the self reference, attempting to assign to a class attribute through the self instance reference won't have the desired effect. Look at the other instance attributes we assign to in the initializer, owner_code, contents, and serial. Assigning to an instance attribute is exactly how we bring those attributes into being. If we attempted to assign to an existing class attribute through the self reference, we would actually create a new instance attribute, which would hide the class attribute, and the class attribute would remain unmodified. You might think that our use of the augmented assignment operator, +=, counts as an assignment, but it doesn't. Augmented assignment works as a read‑modify‑write operation, which modifies the existing object, the class attribute, in place. If we were to instead use self.next_serial = self.next_serial + 1, this would cause the creation of an instance attribute, as well as the class attribute, with the instance attribute taking precedence over the class attribute when next read through self. All said, it's much better and safer to access class attributes as, well, attributes of the class object rather than via the instance. The rules can be a little confusing, so let's recap in the abstract. Here's a very simple class, which has an instance attribute a and a class attribute b. The instance attribute can be accessed via the instance object reference, self, and the class attribute can be accessed via the class object reference, MyClass. The class attribute b can also be accessed via the instance object reference self. This only works because there is no instance attribute called b yet. Assigning to self.a re‑binds the instance attribute to a new value. However, assigning to self.b does not re‑bind the class attribute to a new value. Instead, it creates a new instance attribute, which hides the class attribute, which is to say that instance attributes take precedence over class attributes when accessed through self. Now accessing self.b accesses the instance attribute. To unambiguously refer to the class attribute, we should go via the class object reference. This is because class blocks or blocks in general do not introduce new scopes in Python. So remember the Python scoping rules: There is no class in LEGB. To create, retrieve, and update class attributes, you need to find an object that is available in one of the LEGB scopes and navigate to the class attribute from there.

Static Methods
Now we have a good understanding of the distinction between instance attributes and class attributes, we can move on to looking at static methods. Going back to our ShippingContainer example, let's perform a small refactoring by extracting the logic for obtaining the next serial number into a method, generate_serial, which we name using a leading underscore, as it's an implementation detail of this class not intended for use outside. Our new private method obtains the next serial number from the class attribute, stores it in a temporary variable, result, increments the class attribute in place, and then returns the temporary, which contains the value before it was incremented. Notice that the first argument to generate_serial is self, which is the instance on which the method will operate. Notice, however, that although we must accept the self instance argument, nowhere in the method do we actually refer to self, so it seems completely redundant. What we would like to do is associate generate_serial with the class rather than with instances of the class. Python gives us two mechanisms to achieve this, the first of which is the staticmethod decorator. To convert our method into a static method, we simply decorate it with staticmethod and remove the unused self argument. Although not strictly necessary, we can also modify the call site to call through the class rather than through the instance by replacing self.generate_serial with ShippingContainer.generate_serial. This refactored code has exactly the same behavior as before. We instantiate ShippingContainer c6 with owner code YML containing coffee, and retrieve its serial number via the new instance with c6.serial. We can take a peek at what the next serial number will be via the class attribute, ShippingContainer.next_serial, which is 1338. Static methods in Python have no direct knowledge of the class within which they are defined. They simply allow us to group a function within the class block when the function is conceptually related to the class. The name staticmethod is something of an anachronism in Python. The static refers to the key word used to indicate the equivalent concept in the C++ programming language, which itself was a reuse of a keyword from the C programming language.

Class Methods
As an alternative to staticmethod, we can use a different decorator called classmethod, which accepts the class object as the first formal argument, by convention using the abbreviated name cls, since we can't use the fully spelled out keyword class as an argument name. The cls argument for classmethod plays an analogous role to the self argument for instance methods. Let's further modify our function to use the @classmethod decorator instead of the @staticmethod decorator. We replace the decorator and add the cls argument. Since cls will refer to the class object, ShippingContainer, we can replace the two direct references to ShippingContainer with cls. When we invoke ShippingContainer._generate_serial, the ShippingContainer class object is passed as the cls argument of the classmethod, which we then refer to within the body of the method to locate the next serial class attribute. The @staticmethod and @classmethod decorators are quite similar, and you may find it difficult to choose between them. This may be even more confusing if you have experience in another object‑oriented language such a C++, C#, or Java, which has a similar static method concept. The rule is simple though. If you need to refer to the class object within the method, for example to access a class attribute, prefer to use @classmethod. If you don't need access to the class object, use @staticmethod. In practice, most static methods will be internal implementation details of the class, marked as such with a leading underscore since having no access to either the class object or the instance object they rarely form a useful part of the class interface. In principle, it would also be possible to implement any static method completely outside the class at the global module scope without any loss of functionality. So you may want to consider carefully whether a particular function should be a module scope function or a static method. The @staticmethod decorator merely facilitates a particular logical organization of the code, allowing us to place what could otherwise be free functions within classes. Sometimes you would like a class to support named constructors, also known as factory functions, which construct objects with certain configurations. Clients of the class call the factories instead of calling the constructor directly. For example, we could use a factory function to implement a method, which creates an empty shipping container. The new @classmethod, create_empty, accepts the class object and an owner_code and then calls the class to create the instance. Let's see how this can be used. We'll create an empty shipping container, c7, by invoking create_empty on the class object, ShippingContainer, returning a new ShippingContainer instance. The class object, ShippingContainer, will be passed as the cls argument of our named constructor. The named constructor then calls the class object, invoking the constructor of the class to create the new instance, which is returned by the constructor. As expected, the contents of the container has been initialized to an empty list accessible through the contents attribute. This technique allows us to support multiple constructors with different behaviors without having to resort to contortions in the __init__ method to interpret different forms of argument list. Here we add a second named constructor called create_with_items for placing an iterable series of items in the container. It works by constructing a list from the items argument and forwarding that to the contents argument of the constructor, again by calling cls. Let's use the new constructor by invoking create_with_items through the ShippingContainer class, passing the owner code MAE and a set of food, textiles, and minerals as the items parameter. The create_with_items named constructor converts the set to a list we can access through the contents attribute of the newly created instance. Let's modify our example to make it slightly more realistic. We'll adjust ShippingContainer to use a string code rather than an integer serial number. In fact, we'll modify our class to use fully‑fledged B‑I‑C or BIC codes, where BIC is the Bureau International des Container or International Container Bureau. Each container has a unique BIC code, which follows a standard format defined in the ISO 6346 standard. We won't go into the details of the coding system here, but we have included a simple Python module called ISO6346.py in the example code associated with this course. All we need to know for now is that the module can create a conforming BIC code, given a three‑letter owner code and a six‑digit serial number together with an optional equipment category identifier. This single letter category identifier will be important as our example evolves. We'll retain the integer serial number generator and introduce a static method called _make_bic_code to combine the owner_code and integer serial number into a single string BIC code. The integer serial number is padded to a six‑digit string using the zfill method of this string class. The new method will delegate much of its work to the ISO6346 module. We'll also rework the initializer function to create and store the BIC code instead of the separate owner code and serial numbers. In __init__, we invoke _make_bic_code through the ShippingContainer class and assign the result to the BIC instance attribute. Let's try the modified code. The BIC attribute is assigned as expected, and the code we get is YMLU0013374. Note the U category identifier. We'll be using this example to demonstrate how static and class methods interact with inheritance as we extend our model of shipping containers.

Static Methods with Inheritance
We'll return to class inheritance in more depth later in this course, but for now, we'll look at how class and static methods behave in the presence of inheritance. Let's introduce a subclass of shipping container called refrigerated shipping container. Refrigerated shipping containers use an equipment category of R, which comprises the fourth character of the BIC code rather than the default U, which signifies unclassified. We must specify this when creating the BIC code by passing an additional category argument to the ISO 6346 create function. We'll do this in an override of the _make_bic_code static method in the refrigerated shipping container derived class. The function override has the same signature, name and argument list as the function and the base class. The implementation is almost identical, except now we're passing R as the category. Let's try instantiating our new class and checking its BIC code. We'll create a refrigerated shipping container, r1, with the owner code MAE containing fish. What happens when we obtain the BIC code through the BIC attribute? Hmmm, this hasn't worked as we had hoped. The fourth character in the BIC code is still U, even though in our overridden method, we specified category R. Let's look deeper to understand why this worked the way it did. In the dunder init method, we have called _make_bic_code through a specific class. To get polymorphic override behavior, we need to call the static method on an instance. Polymorphism with inheritance means that the version of a method called will depend on the type of the object on which it is invoked. Let's experiment a little at the REPL so we understand what's going on. We'll test the static method by calling directly on the base class with shipping container _make_bic_code MAE 1234. We get U for unclassified. So far, so good. And then we'll try directly on the derived class, refrigerated shipping container _make_bic_code MAE 1234 again. Now we do have an R for the refrigeration category code for the fourth character in the BIC code. If you're wondering why the last digit also changed, it's because the last digit is a check digit computed by the ISO 6346 implementation. In both cases, we got exactly what we asked for. The class‑specific versions of the static methods are called. Now we'll try through some instances. First off, the base class shipping container with some textiles. We'll call the private _make_bic_code directly via the instance. passing our own owner code and serial number 1234. Here, the fourth character of the result is the default U. So we know the base version was called through the instance. Notice that although we've created an instance, we're ignoring any instance attribute data when we invoke the static method directly in this way by calling the method directly. We would not normally do this in production code, but it's fine for experimentation here in the safe confines of a throwaway REPL session. Now we'll instantiate the derived class, a refrigerated shipping container with some frozen peas, r._make_bic_code MAE 1234. We can see from the R in the fourth place that the derived class is called. So we can get polymorphic dispatch of static methods, but only when we call the method through an instance, not when we call the method through a class. To get this desirable behavior in our production code, we must modify dunder init in the base class to use polymorphic dispatch of the static method by calling through the instance, self. With this change in place, we get polymorphic BIC code generation from the single constructor implementation. We'll create refrigerated shipping container r2 with owner code MAE containing some fish again. The BIC code we retrieve has the all important R. Be aware then that by calling static methods through the class, you prevent overrides being invoked, at least from the point if you're at the base class, making your design much less flexible and certainly less extensible. If you need polymorphic dispatch of static method invocations, call them through the self instance.

Class Methods with Inheritance
Now let's look at how class methods interact with inheritance. The class methods we defined in the base class will be inherited by the subclass. And what is more, the cls argument of these methods will be set appropriately. So calling create_empty on RefrigeratedShippingContainer will create an object of the appropriate subtype. For those of you coming to Python from other popular object‑oriented languages, you should recognize this ability to have class methods behave polymorphically as a distinguishing feature of Python. These invocations work because the base class dunder init initializer method is inherited into the subclass. The other factory method, create_with_items, also works as expected. Let's create RefrigeratedShippingContainer r2 with ice and peas, using our named constructor, create_with_items. The type of the created instance is indeed RefrigeratedShippingContainer, and the contents are as specified. Let's move on by making our RefrigeratedShippingContainer more interesting by adding a per‑container temperature setting as an instance attribute. First, we'll add a class attribute, which defines the maximum temperature of a refrigerated container. This is a constant, so we'll follow convention by using an uppercase identifier. Next, we'll need to override the dunder init method in the subclass. This overridden method does two things. First, it calls the base class version of dunder init, forwarding the owner_code and contents arguments to the base class initializer. Unlike other object‑oriented languages, where constructors at every level in an inheritance hierarchy will be called automatically, the same cannot be said for initializers in Python. If we want a base class initializer to be called when we override that initializer in a derived class, we must do so explicitly. Remember, explicit is better than implicit. To get a reference to the base class instance, we call the built‑in super function. We then call dunder init on the returned reference and forward the constructor arguments. We'll be covering super in a lot of detail later in the course, so don't concern yourself overly with it just now. We're just using it so the subclass version of dunder init can extend the base class version. This done, we validate the celsius argument with respect to our MAX_CELSIUS class attribute, raising a ValueError in the case where the specified temperature is invalid. If the temperature is valid, we continue and assign to the self.celsius instance attribute. Let's try it out. We'll create a RefrigeratedShippingContainer containing some onions, using our create_with_items named constructor. Oops, there's no way the factory methods in the base class can know, or indeed should know, the signature of the dunder init function in derived classes, which in this case requires the extra celsius argument. Fortunately, we can use extended argument syntax or arbitrary keyword args to work around this. By having our factory functions accept **kwargs, which we pronounce kwargs, and forward them unmodified to the underlying constructors, we can have our base class factory functions accept arguments destined for derived class initializers. We change the create_empty class method to accept **kwargs and passed the **kwargs argument onwards to the constructor. Then we'll make a similar change to create_with_items. The ShippingContainer initializer should accept **kwargs but can reasonably expect the argument dictionary to be empty, as it makes no use of it. We'll also modify the derived class initializer to make celsius a keyword‑only argument by inserting a singular star into the argument list before it. If you're not familiar with the ins and outs of Python's fairly complicated argument list specifications, see our Core Python: Functions and Functional Programming course, earlier in the learning path. It's good practice for the derived class initializer to also accept and forward **kwargs to its super class initializer. We'll see why later in this course when we discuss multiple inheritance. Now the additional celsius argument is accepted by the named constructor and forwarded to the regular constructor. Since we invoked the named constructor on the derived class, the regular constructor will be the derived class constructor, which is expecting a celsius argument. Python will match up the celsius entry in **kwargs with the celsius keyword argument of the RefrigeratedShippingContainer initializer. Let's exercise all of this at the repl. We'll create a RefrigeratedShippingContainer, specifying a temperature of 2 Celsius. We can then retrieve the contents as expected, but now also the temperature via the celsius attribute. So far, so good. We can construct instances of our derived class using a factory function defined in the base class and can gain access to our new celsius attribute as expected. Unfortunately, our design also allows us to circumvent the MAX_CELSIUS class attribute by assigning directly to the celsius instance attribute. Here we set the temperature to 12 Celsius, well above the maximum Celsius of 4. This violates a class invariant, and we should find a way to prevent it. Before moving on to address that problem, remember that in general, good object‑oriented design requires that base classes should have no knowledge of their subclasses. In this case, ShippingContainer should have no direct knowledge of more specialized types of ShippingContainer like RefrigeratedShippingContainer. To achieve this, use **keyword args to thread arguments through named constructor class methods to more specialized subclasses.

Properties
It's time to look at properties, an important capability of Python classes. Back to our ShippingContainer. The RefrigeratedShippingContainer initializer establishes an important class invariant, that the temperature of the container should be below some specified maximum. We've seen that that invariant can be violated by directly assigning to the celsius instance attribute. Let's fix that. Using the Python tools we already have at our disposal, one approach would be to rename the celsius attribute to _celsius to discourage meddling and wrap the attribute with two methods called get_celsius and set_celsius, with the setter performing validation against MAX_CELSIUS. Such an approach would work but would be considered deeply unpythonic. Furthermore, it would require all uses of the celsius attribute to be adjusted to use the method call syntax. Fortunately, Python provides an altogether superior alternative to getter and setter methods called properties, which allow getters and setters to be exposed as seemingly regular attributes. This facilitates a graceful upgrade in capabilities from attribute to property. As with static and class methods, decorators are the basis of the property system. Let's take a look. First, we'll rename our celsius attribute to _celsius to indicate that it's no longer to be considered part of the public interface. Then we'll define a new method, which can be called celsius, as we freed up that name by renaming the attribute. The new method will retrieve the renamed attribute. The method will be decorated with the built‑in property decorator. Back in the repl, once we have reimported our module and instantiated a new RefrigeratedShippingContainer with a suitable temperature, we can see that we can still get hold of our attribute value using the regular attribute access syntax, without the function call parentheses. What's happened here is that the property decorator has converted our celsius method into something that when accessed behaves like an attribute. The details of exactly how this is achieved are beyond the scope of this course. For the time being, it's sufficient to understand that property can be used to transform getter methods so they can be called as if they were attributes. If we attempt to assign to the attribute, we'll receive an AttributeError informing us that the attribute can't be set. This error is useful. We've just seen how to make read‑only attributes by defining only a getter. If we want writable properties, however, we need to define a property setter, which uses another decorator. But first we need to cover some background information. Recall that decorators are functions which accept one function as an argument and return another object, which is usually a wrapper around the original function, which modifies its behavior in some way. If you need to review the details, take a look at our course, Core Python: Functions and Functional Programming, earlier in the core Python learning path. In any case, here's a brief refresher. Here we show a regular function, which is bound by the def statement to the name f, and then processed by a decorator, which creates a wrapper function object which refers back to the original function. Finally, application of the decorator rebinds the name f to the wrapper. Moving on to the specifics of properties, we'll start with an Example class into which we'll place a getter function, p. We decorate this with the built‑in property decorator, which creates a special property object, which contains a reference back to the original getter function before the p name is rebound to the property object. This much we've already seen with our celsius property. If needed, we can then create a separate setter function, which can also be called p, although this will also need to be decorated. This time, rather than the built‑in property decorator, we use a decorator specific to this property, which is itself an attribute of the property object that was created when we defined the getter. This new decorator is always called setter and must be accessed via the property object. So in our case, it's called p.setter. Decorating our setter function with the p.setter decorator causes the property object to be modified, associating it with our setter method, in addition to the getter method. When we decorate our celsius getter with property, the returned object is also bound to the name celsius. It is this returned property object which has the setter attribute attached to it, which is another decorator, which is used to decorate our setter definition. This is all fairly mind‑bending, and we apologize if you've not yet consumed enough caffeine today for this to make sense. As usual, an example will clarify matters somewhat as, frankly, this is much simpler in practice than it is in theory. Let's define a celsius setter. The setter is a method which conventionally has the same name as the getter, decorated by the setter decorator retrieved from the property object, in this case, celsius. The setter accepts the proposed new value as an argument and validates this value against the MAX_CELSIUS class attribute, raising a ValueError if validation fails. If validation succeeds, the setter proceeds to assign the new value to the private _celsius attribute. We can now assign to the property using regular attribute syntax, which will call the setter method and execute our validation code. We'll create yet another container holding some frozen prawns with an additional temperature of ‑18 Celsius. We can retrieve the temperature from the celsius property, just as if if it were an attribute. With the property setter in place, we can also set the temperature, so long as it's below MAX_CELSIUS. Here we set to ‑19 Celsius. If we try to set a temperature above MAX_CELSIUS, our property setter raises the ValueError, and the class invariant is maintained. Shipping containers are moved around the world between cultures which prefer the Celsius measurement scale and those which prefer the Fahrenheit scale. Let's round off this section by adding support for Fahrenheit property access to the same underlying temperature data. Here's the full code for the revised class. We've added two static methods, _c_to_f and _f_to_c, to perform temperature conversions. These are good candidates for static methods, since they don't depend on the instance or class objects, but don't really belong at global scope in a module of ShippingContainer classes, either. The getter and setter methods for our new fahrenheit property are implemented in terms of our new temperature conversion static methods, and significantly, in terms of the existing celsius property rather than going directly to the stored _celsius attribute. This is so we can reuse the validation logic in the existing property. This shows that properties don't have to be backed by attributes. The value of our Fahrenheit property is computed on the fly when needed. Finally, notice that we can simplify our subclass initializer by leaning on the celsius property setter validation here, too. We simply assign through the property rather than directly to the attribute and get validation for free. This is a technique called self‑encapsulation, where even uses of attributes internal to the class go through the property getter and setter rather than directly accessing the underlying attribute. It's a powerful technique for helping establish and maintain class invariants such as our temperature constraint. Let's give our changes a whirl at the repl. Instantiation works as before, but now the temperature is validated internally by our property setter. The Celsius getter returns the temperature we provided at construction. The Fahrenheit getter returns the fahrenheit equivalent. The fahrenheit setter internally does the conversion to Celsius then assigns through the celsius setter we can return the Celsius equivalent of the Fahrenheit temperature we just set. Attempting to create an instance of an invalid temperature causes the celsius setter to raise the ValueError. Although Python properties provide a graceful upgrade path from public instance attributes to more encapsulated data wrapped by getters and setters, you should bear in mind that overuse of getters and setters can lead to poor object‑oriented designs with tightly coupled classes which expose to many details, albeit thinly wrapped in properties. In general, we recommend reducing coupling between objects by implementing methods which allow clients to tell objects what to do rather than having clients request internal data so that they can perform actions themselves.

Properties and Inheritance
It's time to see how properties interact with inheritance. Shipping containers have been so successful because they come in standard sizes. They're always 8‑feet wide and 8.5‑feet high. They do come in different lengths however. 20‑foot containers, 40‑foot containers, and so on. We'll modify our ShippingContainer class to contain the width and height as class attributes, since they are the same for all containers, and the length as an instance attribute, since that varies between individual containers. First, the two class attributes for width and height. Then we'll add support for the length_ft instance attribute to the initializer. This, in turn, requires we modify our create_empty named constructor and our create_with_items named constructor to accept and forward the new length_ft argument. We'll allow the read‑only property, done by defining only a getter, which reports the volume_ft3 of a container instance, making the simplifying assumption that the sides of the container have 0 thickness. Its definition takes the product of the height, width, and length to give a result in cubic feet. Notice that the height and width are qualified with the class object and the length with the instance object. Constructing an empty 20‑foot container, we can now determine that it has a volume of 1360 cubic feet. That works for the ShippingContainer base class. But we need to do a bit more work for the RefrigeratedShippingContainer subclass. We must modify its initializer to accept the new length_ft argument and forward its value to the base class initializer via super. In the REPL, we can see that the volume_ft3 property is inherited into the RefrigeratedShippingContainer without issue. We know, however, that the cooling machinery in a refrigerated shipping container occupies 100 cubic feet of space, so we should subtract that from the total. Let's add a class attribute for that volume and override the volume_ft3 property with the modified formula, which takes the product of the three external dimensions, then subtracts the fridge volume in cubic feet. This works well enough. A 20‑foot shipping container has an internal volume of 1260 cubic feet. Unfortunately, we've duplicated the bulk volume calculation between the overridden property and its base class implementation. Having important rules defined more than once in the same code base is bad practice. So we'll remedy that by having the derive class property delegate to the base class. As before, this is done by retrieving the base class property using a call to the super function. So overriding property getters, like volume_ft3, is straightforward enough. We just redefine the property in the derive class as normal, delegating to the base class via super if we need to. Unfortunately, overriding property setters is much more involved. Let's see why. To demonstrate, we'll need a property for which it makes sense to override the setter. We'll introduce a third class into our class hierarchy, representing a heated refrigerated shipping container. I'm not making this up. Such things do exist, and their purpose is to maintain a temperature within a wide range of ambient conditions. For the purposes of this exercise, we'll assume that such containers should never fall below a fixed temperature of ‑20 Celsius, while also respecting the existing maximum temperature constraint that will inherit from RefrigeratedShippingContainer. We'll use another class attribute, MIN_CELSIUS, to represent this lower temperature limit in the third class. We don't need to override the Celsius getter here, but we do need to override the Celsius setter in order to respect the additional temperature rule this class requires. Let's have a go. The body of our setter uses Python's convenient chained comparisons to ensure that the proposed temperature value lies within the inclusive range specified by MIN_CELSIUS and MAX_CELSIUS before assigning to the internal _celsius attribute. Unfortunately, this obvious approach doesn't work, and the code won't even import correctly. This is because the celsius object from which we retrieve the setter decorator is not visible in the scope of the derived class. We can solve this by fully qualifying the name of the celsius object with the base class name, RefrigeratedShippingContainer.celsius.setter. Now this works just fine. We can happily create instances of the HeatedRefrigeratedShippingContainer through our existing named constructor with a length of 40 feet and a temperature of ‑18 Celsius. Any attempt to set a temperature below the minimum via the overridden property causes the ValueError to be raised with the Temperature out of range message. It's notable and good that attempting to construct an instance with an out‑of‑range temperature also fails with this error, even though we haven't defined the __init__ image method for the new class. Recall that the initializer in the RefrigeratedShippingContainer assigns to the underlying _celsius attribute through the Celsius property, self‑encapsulation, so our overridden property validator is invoked during construction too, thanks to polymorphic dispatch, another benefit of the self‑encapsulation we use in the RefrigeratedShippingContainer initializer. It's not all good though. Our overridden property is certainly violating the Don't Repeat Yourself, or DRY, principle by duplicating the comparison with MAX_CELSIUS, which is already implemented in the parent class. Let's try to eliminate the duplication by delegating to the super class to test against the upper temperature limit via super. Surprisingly, this doesn't work. We get a runtime error, AttributeError: 'super' object has no attributes 'celsius'. With a combination of super and properties, there is much hidden machinery at play, which we won't get into in this intermediate level course. That said, we will be learning more about super very soon. This problem is solvable by retrieving the base class property setter function from the base class property and calling it directly, remembering to explicitly pass self. Recall that the property object produced by the property decorator keeps references to the getter and setter methods called fget and fset respectively. Let's see how this behaves. We create a HeatedRefrigeratedShippingContainer with a valid temperature of ‑18 Celsius. Now we're told when the requested temperature change is specifically too hot at 10 Celsius or too cold at ‑26 Celsius rather than just out of range. We've been careful throughout to route all access to the _celsius attribute through the Celsius property. As such, none of the other code, which needs to respect the constraints, needs to be modified. For example, the Fahrenheit setter, although not itself overridden, also respects the lower temperature limit now. Self‑encapsulation, which comes at the low price of not having to type underscores everywhere, easily pays for itself. For reference, ‑14 Fahrenheit is a little below the low temperature limit of ‑25 Celsius. All this works, but to be frank, we think this implementation of the overridden Celsius property is a bit of a mess containing as it does two direct references to the base class. Perhaps not so bad in this case, but the class defining the original property could have been many levels up in the inheritance hierarchy. Knowing this technique is useful, though, for the times when you're not in a position to modify the base class implementation. We are, though, so we'd like to find a more elegant, albeit more intrusive solution, and that's what we'll pursue next.

Overriding Properties with Template Methods
In this section, we'll introduce a simple technique for overriding properties. We've seen that it's straightforward to override property getters but somewhat more involved and quite syntactically messy to override property setters. In this demo, we'll employ a standard design pattern, the template method, to resolve these shortcomings and confer some additional benefits on our code. This pattern was documented in the language‑agnostic Design Patterns book by the so‑called Gang of Four, although it's been known for much longer. The template method is a very straightforward design pattern where we implement operations in outline in a base class method, deferring details to subclasses. We do this by calling methods in the base class, which are either not defined at all or which have trivial implementations which raise an exception such as NotImplementedError, and so must be overridden in order to be useful. An alternative is that we do supply useful default implementation in the base class but allow them to be specialized in derived classes. As an old saying goes, there's no problem in computer science which can't be solved by an additional level of indirection. Let's start by using the template method to implement a getter. We'll use the volume_ft3 property to demonstrate, because that is a property for which we override the getter in a subclass. To do this, we'll extract the computation from the getter in the base class into a new function, _calc_volume. The volume_ft3 property is now a template method. It doesn't do anything itself except delegate to a regular method, which could easily be overridden in a derived class. We'll now override this regular _calc_volume method in the derived class by converting the existing property override into an undecorated method. Our implementation leans on the base class implementation by using a call to super. With this change in place, we get the behavior we're looking for without having overridden the property itself. A regular shipping container gives a volume of 1360 cubic feet, and a refrigerated shipping container gives a volume of 1260 cubic feet. We can use the same technique to override a property setter without having to remember any funky syntax or remember the internal f get and f set details of property objects. We'll turn the celsius setter into a template method which delegates to a regular undecorated _set_celsius method. Down in the HeatedRefrigeratedShippingContainer implementation, we can now remove the horrible property override construct and simply override the regular _set_celsius method instead. In this case, we've decided to use super to call the base class implementation, something else which is now suddenly easier. Here it is in action, giving appropriate error messages for the low temperature case and for the high temperature case. It turns out, the best way to override properties is not to override them at all. Don't override properties; have your properties delegate to regular methods instead, and override those. We'll leave you with this thought from Kevlin Henney, "All problems in computer science can be solved by another level of indirection...except for the problem of too many levels of indirection."

Summary
Let's briefly summarize what we've seen in this module. We've covered the distinction between class attributes and instance attributes. We've demonstrated how class attributes are shared between all instances of a class. We've shown how to refer to class attributes from within or without class definition by fully qualifying them with the class name. We've warned against attempting to assign to class attributes through the self instance, which actually creates new instance attributes. We have used the static method decorator to define methods within the class, which depend on neither the class nor the instance. We've used the classmethod decorator to define methods which operate on the class object. We've implemented an important idiom called N amed Constructors using class methods. We have shown how static and class methods behave with respect to inheritance. We've shown that static and class methods can support polymorphic method dispatch when invoked through an instance, rather than through a class. We have introduced properties to wrap attributes with getters and optional setter methods. using the property decorator. Finally we showed an easy way to override properties by having them delegate to regular methods, which can easily be overridden, an example of the template method design pattern in action. We've covered a lot of ground, including some complex interactions of Python features in this module, and it's important you understand them before moving on.

String Representation of Objects
Overview
It's a very common need to be able to produce a string representation of an object. in this module, we'll look at the various ways we can render objects to strings in Python and understand when and why to use the various approaches. Python has three built‑in functions for obtaining a string representation of an object, repr(obj), str(obj), and format(obj). We'll take a look at each of these in turn and see how to customize their behaviors with respect to your own classes. Understanding and properly using the various string representations in Python is important for writing maintainable, debuggable, and human‑friendly programs. And this module will show you what you need to know to use them properly. Let's start by looking at the default behavior of a new class. The Position class models of value type representing geographic position on the surface of the Earth, or any planet, really. It has an initializer, which accepts the latitude and longitude in degrees. The latitude is displacement north from the equator at 0, so latitudes greater than 0 up to the positive 90 degrees are in the Northern Hemisphere, and latitudes less than 0 down to negative 90 degrees are in the Southern Hemisphere. The longitude is displacement east from the prime meridian, with 0 on Earth being through the Royal Observatory at Greenwich, England. Longitudes greater than 0 up to positive 180 degrees are in the east, and longitudes less than 0 down to negative 180 degrees are in the west. The initializer validates these invariants, raising value errors if they can't be established before assigning to two private attributes, _latitude and _longitude. Position also provides read‑only properties for both latitude and longitude. We've mentioned the three built‑in functions, repr, str, and format. What do they give us by default? Let's see what happens when we instantiate a position and ask for string representations. Let's make a position for Oslo, Norway, where we're based, at 60 degrees north and 10.7 degrees west. We'll try each of the string‑creating functions in turn. First of all, we'll ask for the repr of Oslo. When passed our Position object, the repr function returns a string containing the type of the object and its containing module and the hexadecimal address of the object in memory. This is only marginally useful, but don't worry. We'll be improving on it soon. Now I'll ask for the str of Oslo. Somewhat underwhelmingly, we get the same result back with the type and the address. Lastly, we'll ask for the format of Oslo. No fireworks here, the same outputs a third time. What is notable is that all three of these functions worked at all. We haven't defined any string conversion behavior for a position. We must be getting these behaviors from somewhere else. The answer is that they're all inherited from the object base class from which our position class implicitly inherits. If we list all of the attributes and methods of object using the built‑in directory function, dir, three stand out in particular, dunder repr, dunder str, and dunder format. These three special methods are the key to customizing the behavior of the built in repr, str, and format functions, respectively. We'll be taking a look at each of these in turn, learning when to use them explicitly, when they are invoked on our behalf, and how to customize their behaviors.

Customizing repr()
In this section we'll explore the repr built‑in function and its customization. Repr is short for representation. As you may already have guessed, the special method __repr__ is the key to customizing the behavior of repr. Let's define __repr__ as a method of our Position class. __repr__ is an instance method, so accept self as its first and only argument. All __repr__ has to do is return a string, which we can create any way we like. We've decided to use an f‑string to assemble a string containing the type of the object, position, and the values of the two properties latitude and longitude. Let's import this into a REPL session and see how it performs. We'll create a new position representing Sydney, Australia with latitude 33.9 degrees south and 151.2 degrees east. By passing our sydney object to the built‑in repr function we can see that behind the scenes our __repr__ function has been called and we get our new representation. One transformative life lesson we've picked up in our careers is when asked to present something to ask who is this presentation for? Well, who is repr for? It turns out that repr is intended for us, the developers of the system. So we're doing ourselves a huge favor by making the effort to implement __repr__ on our own classes. We strongly recommend you try to train yourself into routinely implementing __repr__, especially for objects which represent values such as our position. We can see a hint that repr is intended for developers by evaluating our position object, sydney, alone at the REPL, which is, after all, a development environment. We get almost, but not exactly, the same output as when we pass sydney through the repr function. When we used the repr function the displayed result was delimited by quotation marks, but this time it isn't. This demonstrates that when the Python REPL needs to display the result of an expression it requests the repr of the result. When we evaluated sydney alone we got the repr of sydney. Earlier, when we evaluated the repr of sydney, the result of the call to repr was a string, and so the Python REPL gave us the repr of the string, which does include the quotation mark delimiters. By overriding __repr__ we can customize the representation we developers see in our own development environments. Now we understand how much we stand to benefit from a good __repr__ implementation. There are a few conventions we can follow. The first guideline is to try to include all necessary objects' state. This is easy for small objects like our position, which includes three pieces of state, its type or class, position, the latitude and the longitude. We have all those in there already so we're in good shape. For more complex objects you'll want to compromise on how much state you should include, but as a class developer you will have a view on which are the most helpful attributes to include. The second guideline is to format the result of __repr__ to be legitimate Python source code. Typically, this means we try to format the result to look like the constructor call, which would produce an object with the same value. To make our __repr__ implementation for Position produce something which looks like a constructor call, we need to wrap the latitude and longitude pair with parentheses and insert a comma to separate them. It's also helpful to our future selves to use keyword arguments. After a few months, you will have forgotten whether the two parameters are latitude or longitude or longitude and latitude. So let's avoid having to remember by being explicit. Back in a fresh REPL session, we can import the revised code and create our Position object representing Sydney again. The representation we get back from the built‑in repr function does indeed look like a constructor call. We can test this by asking Python to evaluate the string as if it were Python source code using the built‑in eval function. This gives us back a second Position object which we've bound to p, containing a value equivalent to our original sydney object. It's important to understand that this is a new Position object, eval, called the position constructor when it evaluated the string r. And so it's a distinct object from sydney. Our repr implementation is pretty good. It serves its target audience, us developers, well and it tells us everything we need to know about this object. We could finesse the implementation of __repr__ a bit though, and we can't resist. Currently, we have the class name hardwired into the result string. This works fine when the type of self is actually position, but in the presence of inheritance self may actually be some subclass of Position. We can make our __repr__ respect future extensions by sub classes by introspecting the actual runtime type of self. We do this by replacing the hard‑coded class name with an expression which returns the same name. There are a couple of ways you might see this written in the wild so we'll show you both and then present a neater third alternative. We can get the class of self using the __class__ attribute. This evaluates to the class object, but we don't want to print that directly. So we ask the class object for its name using __name__. You should see this regularly in other folk's code, and it's perfectly acceptable, even if a little ugly. The first improvement we can make is to realize that the class of an object is the same as the type of an object. So we can use the built‑in type function rather than retrieving the class attribute directly. It's good practice to prefer built‑in functions over direct special attribute access when possible. Unfortunately, there's no built‑in function to get the name of a class, yet we find ourselves doing this often enough that we often extract a small utility function called typename. Typename accepts any object, gets the type of that object, which is its class, and then gets the name of the class using __name__. To show this working with inheritance we'll create a couple of sub classes of position called EarthPosition and MarsPosition. These classes will inherit everything they need from position so we can give them minimalist class bodies containing just a single pass statement each. Back in a fresh REPL session, we'll create an Earth position for the summit of Mauna Kea, the largest volcano on Earth with a latitude of 19.82 degrees north and a longitude of 155.47 degrees west. See how our __repr__ reports the concrete subclass of the position object EarthPosition, no longer just the position base class where __repr__ is defined. For completeness, here's the position of the largest volcano on Mars, Olympus Mons, which in Mars' coordinate system is located at 18.65 degrees north and 133.8 degrees west. Again, __repr__ returns the concrete type. We set out to customize the behavior of the built‑in repr function with respect to our position objects. And by all accounts, we've succeeded. We overrode the default implementation of __repr__ inherited from the object base class with a version which returns a string representation designed to contain a legitimate Python source code constructor expression. As a rule, you should always write a __repr__ implementation for your classes. Before moving on, let's check on the status of str and format. Perhaps surprisingly, both of these have also been updated to use our new representation from __repr__. Clearly, we have more to learn.

Customizing str()
Having successfully customized the output of repr for our position class, but also having inadvertently customized the output of str and format, let's try to get control over str. The built‑in str function isn't just another way of converting objects to strings. Remember that str is actually the built‑in string class, and that calling a class is how we create new objects of that type. So the str function is actually the string constructor. Helpfully, the string constructor delegates to the special method, then the str on the object passed to it. So we can control how our objects are converted to strings. All python objects have a __str__ method because they inherited default implementation from the object base class. As we saw, even though we haven't overridden __str__ yet, the output has changed to match that of __repr__. That's because the default implementation of __str__ is to delegate to __repr__. If we want str to return something different, then we need to specialize its behavior by overriding __str__ in our own class. We saw that repr is primarily intended for us developers. This raises the question who is the str representation for? As is too often the case, the answer is who's asking? But a good starting point is to think of str as being for consumers of the system we're building, such as users. This suggests that the str representation is intended for readable, human‑friendly output. Not that developers aren't human or friendly, of course. Think of cases where the string representation might appear in the user interface or be integrated into natural language text. This, in turn, indicates that we can leave out technical implementation details such as the class or argument names, which are of no interest to the users of our system, and instead focus on making something aesthetically pleasing and, well, natural looking in their context. So, how do we normally present geographic positions? Instead of positive and negative prefixes, we use suffixes of N, S, E, and W for north, south, east, and west. We also include a degree symbol to indicate the units of measure, and a comma to separate the latitude, which comes first from the longitude, which comes second. Here's the position of Mount Erebus, an active volcano in Antarctica, 77.5 degrees south by 167.2 degrees east. Let's have a crack at implementing this in our Position class. A good approach is to write in a real example, and then replace each part in turn with a curly brace placeholder. We'll use an F‑string again, and replace the latitude and longitude with placeholders, which refer to our properties, another example of the self encapsulation we discussed in the previous module of this course. This is a good start, but we still have the south and east values hard coded. There's an upper limit to how much complexity you should be tempted to cram into F‑string expressions, so we'll create two new properties which generate hemisphere suffixes. The first latitude hemisphere will use a conditional expression to return north if the latitude is greater than or equal to 0; otherwise, south. The second longitude hemisphere will use a conditional expression to return east if the latitude is greater than or equal to 0; otherwise, west. We have followed convention, which is to place 0 degrees latitude in the Northern Hemisphere and 0 degrees longitude in the Eastern Hemisphere. Now we're using hemisphere designators instead of numeric signs, we need to take the magnitudes of the latitude and longitude using the built‑in absolute value, or abs function. This line of code is very expressive, but it's getting a bit long, so we'll wrap the string expression in parentheses, allowing us to insert a line break and use implicit string concatenation to assemble a single string from two shorter strings. Let's try it out. Mount Erebus is an EarthPosition ‑77.5, 167.2, and the str gives us a beautifully‑formatted 77.5 degrees south by 167.2 degrees east. Very nice. In addition to customizing the standard string construction, it is the __str__ version, which is used when displaying an object with the print function. Mount Erebus is located at 77.5 degrees south by 167.2 degrees east. This is a further reminder that __str__ is intended for external consumers of the string representation. We're doing well so far. We've managed to customize __repr__ for developers and __str__ for other users, which only leaves format, which, if you remember after we implemented __repr__ , returned the __repr__ representation. Let's check up with what's happening there. Format mount_erebus. Now we receive the result of the __str__ implementation. In the next section, we'll have to investigate formats more closely.

Customizing format()
The third and final string formatting function we'll look at customizing is format. We've seen that repr output can be customized by overriding __repr__ and that str output can be customized by overriding __str__. Thankfully, the pattern continues, and we can customize format output by overriding __format__ There's another pattern at play here too. We saw that the default implementation of __str__ inherited from object delegates to repr. We also saw at the close of the previous section that the default implementation of __format__ also inherited from object delegates to str. We'll start with a dummy implementation of __format__ in order to understand under what circumstances it's invoked. We'll just return the fixed string saying FORMATTED POSITION. Unlike __repr__ and __str__, which accept only the instance to be formatted, self, __format__ accepts a second argument, format_spec. We must accept this to match the signature of the method we're overriding, but we'll ignore it for the time being. Don't worry, though. We'll get to it soon enough. In the REPL, let's create a position for the South American mountain, Aconcagua, at 32.7 degrees south and 70.1 degrees west. The repr result is, as before, provided by __repr__, and the str result provided by __str__. The format result is now provided by __format__. But where else is __format__ used? The other key places are in f strings, The highest mountain in South America is located at Aconcagua, and the placeholder there, and with the format method of the string class. That's because both f strings and the format method delegate to the built‑in format function, which in turn delegates to __format__. This means that if we understand the built‑in format function, we can apply that knowledge to f strings and the format method. Let's step back for a moment from our worldly position example to investigate formats with a built‑in type, the float. Here's a floating point number, q, which has a value of 7.748091 times 10 to the ‑5. Floating point numbers generate lots of number formatting difficulties, and we've chosen this one carefully to illustrate. The format of q is what we started with, 7.748091 with an exponent of ‑5. Not everybody is familiar with scientific or exponential e notation, so let's get Python to display q in a more accessible way. This is where the optional second argument to format comes into play. The second argument is a format specifier, a string which controls how the first argument will be formatted. The details of what values are allowed by the format specifier depend on the type of the first argument to format. Let's experiment with the options for floats. By passing f as the format specifier, we can request fixed point representation, which displays 0.000077 without the exponential notation using e. Python has only given us six decimal places, which is the default. We can explicitly request seven, though, with a different format specifier, .7f, or 11 digits using .11f, which allows us to recover all the significant figures of the number we first started with, 0.00007748091. We can request an explicit sign even for positive numbers by using plus sign in the format string before the dot, and we can right‑align the number to a field width of 20. In short, there's a lot of power and flexibility, and we could put together a whole course on number formatting in Python. A key point to understand is that interpretation of these format strings is not done by the built‑in format method itself. The task is delegated by format to the __format__ method of the object being formatted, in this case float __format__. You'll find that different types support different mini‑languages in their format specifiers. For example, if we try to use the float‑specific format specifier with a string, we'll get a value error telling us it couldn't make sense of it. How does all this stuff about format specifiers relate to f strings and the string format method? Using an unadorned f string placeholder is equivalent to calling the single argument former format. Here, the conductance quantum comes back to us in scientific notation. If we place a colon after the variable identifier in the placeholder, we can pass the format specifier too, q:.6f. Here .6f is the format specifier. Now we get the conductance quantum displayed to six decimal places. Or we can force exponential notation even for small numbers with less precision by using .2e for exponent. Now we understand the uses of format and how it can be used via format placeholders, let's depart the quantum realm to return better informed to the more mundane world of geographical positions. We would like to be able to specify the precision of our latitude and longitude coordinates while ensuring they always appear in fixed .4 without potentially confusing scientific notation. We'll clone the implementation of __str__ into __format__ and evolve it from there. We must resist the temptation to squeeze too much complexity into our f strings, though, so we'll refactor in preparation for the new feature. Always a good idea. Let's extract the expression for absolute latitude into a local variable called latitude and extract the expression for absolute longitude into a variable called longitude. Taking small steps, we'll now format the two floating point values resulting from these expressions with two calls to the built‑in format function. We won't get too adventurous yet though. We'll supply a hardcoded format specifier which stipulates two decimal places in fixed point format with .2f. Testing at the REPL, we get nicely rounded latitude and longitude values in our formatted string. We're not yet making use of the format_spec argument to __format__, so let's make this a little bit more sophisticated by allowing us to specify a precision with a format specifier like .0, .1, or .2 for the number of decimal places. We'll refactor by extracting the format specifier we use for the latitude and longitude components into a local variable component format_spec. Now we have to pause the format_spec argument. We'll use the partition method of the str class to partition the format specifier we're given into three parts, the part before the dot, which is empty in our case, which we'll call prefix, the dot itself, which we'll call dot, and the part after the dot, which we'll call suffix. We'll check the value of the dot variable to detect the case where there is a dot in the format specifier, and if there is, we'll convert the suffix, which contains the string after the dot, into an integer. We can use that integer to build another format specifier, which will be used to format the latitude and longitude components. Brief experimentation at the REPL shows that this works very well. Using the Matterhorn again, we can display its position to one decimal place with format specifier .1 or even no decimal places with a format specifier of .0. What happens when we don't pass the second argument for format? In this case, the built‑in format function passes an empty string as the format_spec argument to our __format__. And our code already handles this case because the empty string doesn't contain the dot, so component format_spec retains the value we initially gave it of .2f. Remember that we don't have to call the built‑in format function directly. We can have f strings do it for us. The Matterhorn is at 45.976 degrees north and 7.659 degrees east. One final convention we should follow is that the default format invocation where format_spec is the empty string should give the same results as __str__. Rather than detect this special case in __format__ and delegate to __str__, we find it more elegant to have __str__ delegate to __format__ via the format built‑in function without the second argument. This also eliminates some unnecessary duplication in our code, leaving us in a very good place indeed.

Summary
Having scaled the heights of object string representation in Python, let's review our surroundings from the summit. Everest is at earth position 27.988056 degrees north, 86.925278 degrees east. The built‑in repr function gives a representation suitable for developers, which includes the object type and named arguments which specify key attribute values. The string constructor gives a default representation suitable for users, 27.99 degrees north, 86.93 degrees east, as does the simplest invocation of the built‑in format function. We can get more control by supplying a format specifier, either as a second argument to format, like .4 here to specify 4 decimal places on each coordinate, or by giving it as part of the format specifier after the colon, here specifying 1 decimal place with .1. We can even force the use of dunder repr from f strings using !r, or force the use of dunder str with !s. Finally, one of our favorite recent features in Python is the ability to display a variable name and its repr value in an f string placeholder by placing an identifier followed by an equals symbol. You can tell this feature is aimed at developers because it displays the dunder repr result. Let's briefly recap. There are three built‑in functions in Python which can be used to produce string representations of objects. Repr provides information for developers and gives the responses seen at the repl. Str provides the default conversion used by string construction and print. Its value is more often seen by end users. Format also provides representations for end users but provides more control than str. The built‑in repr function delegates to the dunder repr special method, the built‑in str function delegates to the dunder str special method, and the built‑in format function delegates to the dunder format special method. All classes inherit default implementations of dunder repr, dunder str, and dunder format from the universal base class object. The default dunder repr contains the object type and address. It's not terribly useful. As such, most classes should override dunder repr to provide unambiguous detail for developers. String formatting in Python is both powerful and flexible, and it's something that most of your classes should support to at least a basic level. Do yourself a favor by implementing dunder repr.

Multiple Inheritance and Method-resolution Order
Review: Single Inheritance
You should already be familiar with single inheritance in Python, where a subclass inherits the attributes of its base class. Python also supports multiple inheritance, allowing a subclass to inherit the attributes of any number of base classes, and it's generally not much more complicated than the single base class case. In this module of Core Python: Classes and Object‑oriented Programming, we'll take a quick review of single inheritance in Python. We'll look at some basic type inspection tools, we'll introduce the concept of multiple inheritance, introduce a small mystery involving class interactions, and see how Python's implementation of inheritance demystifies it. In doing so, we'll explore Python's notion of method resolution order, and we'll see how Python's super mechanism works. Finally, we'll take a quick look at the heart of Pythons object system, the appropriately‑named object class. Before we look at multiple inheritance, let's do a quick review of single inheritance. The syntax of single inheritance is part of the class declaration, with the base class put in parentheses after the class name. What this essentially means is that SubClass will have all of the methods of BaseClass, and SubClass will be able to override these methods if it wants to. In other words, SubClass can do everything that BaseClass can do, and it can optionally modify or specialize that behavior. In general, a subclass initializer will want to call its base class initializer to make sure that the full object is initialized. Remember, though, that if a subclass doesn't define an initializer, then the base class initializer is called when an instance of the subclass is created. To see the basics of inheritance in action, let's define a very simple base class called Base that simply prints out what it's doing when you call functions on it. If we create an instance of Base, we see, of course, that its initializer is called, and calling the f method on that instance uses Base.f. There should be nothing surprising here. Let's now define a subclass of Base called Sub. This subclass doesn't add any functionality to Base at all. Because we haven't defined an initializer for Sub, we can see that it inherits Base's initializer, and likewise, Sub also inherits Base.f. Sub can override Base.f by simply redefining the method itself. Now, if we create an instance of Sub, we see that the Base initializer is still being called, but Sub's definition of f is now used. Finally, let's give Sub its own initializer. Now when we create a new instance of Sub, we only see Sub's initializer being called. If you're used to languages like C++ and Java, you might have expected Python to also call Base's initializer when creating a Sub instance, but this isn't how Python behaves. Rather, Python treats the __init__ method just like any other method, and it doesn't automatically call base class initializers for subclasses that define initializers. If you define an initializer in a subclass and still want to call the initializer of a base class, and this is often important to do, then you need to call it explicitly using the super function. Let's finish this small example by doing that. Now, when we construct an instance of Sub, we see both the Sub and Base initializers being called. The fact that Python doesn't provide special support for calling initializers is important to understand, and if it seems strange to you, don't worry, it soon becomes second nature. Hopefully this small example was just review for you. If you need to refresh your memory of basic inheritance in Python, you can always refer to the Core Python: Getting Started course, which covers it in some detail. As a more concrete and practical example of how to use inheritance in Python, we'll first define our own simplified list class called SimpleList. SimpleList uses a standard list internally, and it provides a smaller, more limited API for interacting with the list data. We'll use SimpleList as the basis for the rest of our exploration of inheritance in Python. Next, let's create a subclass of SimpleList which keeps the list contents sorted. We'll call this class SortedList, and it looks like this. You can see that the class declaration includes the name, followed by SimpleList in parentheses, so Simple.List is the base class of SortedList. The initializer for SortedList takes an optional argument, which is a sequence for initializing the list's contents. The initializer calls SimpleList's initializer, and then immediately uses SimpleList.sort to sort the contents. SortedList also overrides the add method on SimpleList to ensure that the list always remains sorted. One aspect of this example that you'll notice are the calls to super. We'll be covering super in more detail later, but in this case it can be understood to mean call a method on my base class. So, for example, calling super.add(x) in SortedList.add means to simply call SimpleList.add(x) with the same self argument or, in other words, to use the base class implementation of add. If we go to our REPL, we can see that SortedList works as expected. Newly constructed instances are sorted, they report the correct length, and the list is kept sorted when new elements are added.

Type Inspection
Single inheritance in Python is relatively simple and should be conceptually familiar to anyone who's worked with almost any other object‑oriented language. Multiple inheritance in Python is not much more complex, and as we'll eventually see, both single and multiple inheritance ultimately rely on a single underlying model. Before we look at multiple inheritance though, we need to lay some groundwork for the examples we'll be using. Along with the SortedList class we defined earlier, we're going to define another subclass of SimpleList called IntList. IntList will be constrained to containing only integers, and it will prevent the insertion of non‑integer elements. To do this, IntList will need to check the types of the items that are inserted, and the tool that we'll use for this is the isinstance built‑in function. Instance takes an object as its first argument and a type as its second. It then determines if the object is of the specified type, returning true if it is and false otherwise. For example, here we see that the decimal literal 3 is an int. The string literal hello is a string, and the float literal 4.567 is not a bytes object. As well as checking for an exact type match, isinstance will also return true if the type of the object is a subclass of the second argument. For example, we can see that a sorted list is an instance of SortedList, and that it's an instance of SortedList's base class, SimpleList. A final twist to isinstance is that it can accept a tuple of types for its second argument. This is equivalent to asking if the first argument is an instance of any of the types in the tuple. For example, this call returns true, because X is an instance of list. Now that we know how to use isinstance, we can define our IntList class like this. You'll immediately notice that IntList is structurally similar to SortedList. It provides its own initializer, and like SortedList, overrides the add method to perform extra checks. In this case, IntList calls its _validate method on every item that goes into the list. _validate uses isinstance to check the type of the candidates, and if a candidate is not an instance of int, _validate raises a type error. Let's see how that looks in the REPL. We can construct an IntList from a sequence of ints, and we can add ints to an IntList. However, if we try to add an object that isn't an integer, we get a type error. So we can see how isinstance can be used to do type checks in Python. Checks like that are uncommon in Python, and while some people consider them to be a sign of poor design, sometimes they're simply the easiest way to solve a problem. There's another built‑in function related to isinstance, which can be used for type checking. This function issubclass operates on types only, rather than operating on instances of types. As its name implies, issubclass is used to determine if one class is a subclass of another. Issubclass takes two arguments, both of which need to be type objects, and it returns true if the first argument is a direct or indirect subclass of the second. For example, we can see that IntList is a subclass of SimpleList, as is SortedList. But of course, SortedList is not a subclass of IntList. We can also use a simple example to verify that issubclass looks at the entire inheritance graph, not just direct parents. We'll first define a subclass of int called MyInt. Then we'll create a subclass of MyInt called MyVerySpecialInt. We can then use issubclass to see that MyVerySpecialInt is a subclass of int. These classes are obviously pretty silly, but they do illustrate that issubclass recognizes that MyVerySpecialInt is indeed a subclass of int, even though it only directly inherits from my int. If you want to learn more about these and other introspection tools in Python, see the course, Core Python: Introspection.

Multiple Inheritance
Now that we've defined two interesting subclasses of SimpleList, we're ready to look at multiple inheritance in Python. Multiple inheritance simply means defining classes with more than one direct base class. This feature is not universal among object‑oriented languages. C++ supports multiple inheritance, for example, while Java does not. Multiple inheritance can lead to certain complex situations, in particular, deciding what to do when more than one base class defines a particular method. But as we'll see, Python has a relatively simple and understandable system for handling such cases. The syntax for defining a class with multiple inheritance is very similar to single inheritance. To declare multiple base classes, simply use a comma‑separated list of classes in the parentheses after the class name. A class can have as many base classes as you want. Just like single inheritance, a class with multiple base classes supports all of the methods of its bases. As long as there's no overlap in the method names of the base classes, it's always easy to see how method calls are resolved. Find the base class with the matching method name, and that's which method gets called. If there's method name duplication across base classes, Python has a well‑defined method resolution order for determining which is used. We'll look at method resolution order in more detail shortly. Let's jump right in and define our own class using multiple inheritance. So far in this module, we've defined SortedList and IntList, both of which inherit from our SimpleList. Now we're going to define a class which inherits from both of these classes and thus has the properties of both. Here's our SortedIntList. It doesn't look like much, does it? We've simply defined a new class and given it two base classes. But if we go to the repl, we can see that it works as we expect. The initializer sorts the input sequence but rejects non‑integer values. Likewise, the add method maintains both the sorting and type constraints defined by the base classes, raising a type error if you try to add a non‑integer. You should spend some time playing with SortedIntList to convince yourself that it works as expected. It may not be immediately apparent how all of this works, though. After all, both IntList and SortedList define add. How does Python know which add to call? More importantly, since both the sorting and type constraints are being enforced by SortedIntList, how does Python seem to know to call both of them? The answers to these questions have to do with the method resolution order we mentioned earlier, along with the details of how super really works. We'll get to all of that very soon. Before that, there are a few more details about multiple inheritance that we need to cover. First, if a class uses multiple inheritance but defines no initializer, only the initializer of the first base class is automatically called when an instance of the class is created. Consider this simple example. We define the class Base1, which prints a message in its initializer. Similarly, we define Base2, which prints a different message in its initializer. Finally, we make the class Sub, which inherits from Base1 and Base2, in that order. If we now create an instance of Sub, we see that only the initializer for Base1 is called. Through the use of super, we can design these classes such that both Base1 and Base2 initializers are called automatically, which is generally what we want. We'll see how to do that soon. Another useful thing to note when thinking about inheritance is the dunder bases member of class objects. Dunder bases is simply a tuple of a class's base classes, as you can see here. SortedIntList inherits from both IntList and SortedList, and those show up in the dunder bases member of the SortedIntList class object. The entries in dunder bases are in the same order as they were declared at the class definition. You don't have to use multiple inheritance to populate dunder bases, as you can see if you look at dunder bases for our IntList class.

Method Resolution Order
We're finally ready to talk about this notion of Method Resolution Order that we've mentioned several times now. In Python, the Method Resolution Order, or simply MRO, of a class is the ordering of a class' inheritance graph used to determine which implementation to use when a method is invoked. When you invoke a method on an object whose class has one or more base classes, the actual code that gets run may be defined on the class itself, one of its base classes, a base class of a base class, or any other member of the class' inheritance graph. The MRO of a class determines the order in which the inheritance graph is searched to find the correct implementation of the method. That's a lot to take in, but MRO's actually very simple, and we'll look at some examples that will make things more clear. First though, we need to look at where our class' MRO is stored. The Method Resolution Order for a class is stored on a special member called __mro__. Here, you can see the MRO for SortedIntList. The __mro__ attribute is a tuple of classes defining the Method Resolution Order. So, how is the MRO used to dispatch method calls? The answer is that when you call a method on an object in Python, Python looks at the MRO for that object's type. For each entry in the MRO, starting at the front and working in order to the back, Python checks if that class has the requested method. As soon as Python finds a class with a matching method, it uses that method and the search stops. Let's see a simple example. First, we'll define a few classes with a diamond inheritance graph. B inherits from A, C also inherits from A, and D inherits from B and C, meaning that in some sense D inherits from A twice. The various func methods simply report which class they come from so that we can see how these classes and methods interact. If we look at D's MRO, we see that Python will check D first, then B, then C, followed by A, and finally object when resolving calls to objects of type D. As you may already know, object is the ultimate base class of every class in Python, and we'll discuss that in more detail later in this module. Based on that MRO, what should we expect if we call func on an instance of D? The call resolves to B's implementation of func because B is the first class in D's MRO that defines the method func. If C had been earlier in the MRO than B then C.func would have been called. We can see this by changing the order of B and C in the definition of D. After this change the new MRO for D puts C before B. And indeed calling func on a new instance of D results in a call to C's implementation. That's all there really is to it. MRO is an ordering of a class' inheritance graph that Python calculates for you. When Python resolves a method call it simply walks along that ordering until it finds a class that implements the requested method. With that in mind, let's see the MRO for our SortedIntList class. As you might have expected, the MRO is SortedIntList, followed by IntList, followed by SortedList, with SimpleList and object bringing up the rear. So calls to add on a SortedIntList, for example, will resolve to IntList.add since IntList is the first class in the MRO with an add method. This raises a very interesting question. When we wrote IntList it never had any connection to the SortedList class. Yet, as we've seen, our SortedIntList is properly maintaining both the sorting constraint and the type constraint of both SortedList and IntList. If add resolves to IntList.add and if IntList is using super to call its base class implementation, how is SortedList being invoked to maintain the sorting? The answer to that mystery has to do with how super actually works. Before moving on to looking at super in detail, you might be curious to know how Python actually calculates the MRO for a class. The short answer is that Python uses an algorithm known as C3 for determining MRO. We won't go into the details of C3 except to mention a few important qualities of the MRO that it produces. First, a C3 MRO ensures that sub classes come before their base classes. Second, C3 ensures that the base class order as defined in a class definition is also preserved. Finally, C3 preserves the first two qualities independent of where in an inheritance graph you calculate the MRO. In other words, the MROs for all classes in a graph agree with respect to relative class order. One outcome of the C3 algorithm is that not all inheritance declarations are allowed in Python. That is, some base class declarations will violate C3 and Python will refuse to compile them. Consider this simple example at the REPL. Here, since B and C both inherit from A, A can never come before B or C in any MRO. This follows from one of the qualities that C3 preserves. However, since D's base class declaration puts A before C and since C3 also guarantees that base declaration order is preserved, C3 cannot produce an MRO that maintains both guarantees. That is, it can't put A both before and after C. Understanding C3 is not critical or really even necessary for using Python, but it is an interesting topic for those curious about language design. If you want to learn more about it you can find plenty of information on the web.

super()
Finally, we have enough background to understand super. So far we've used super to access methods on base classes, for example, in SortedList.add, where we used super to call SimpleList.add before sorting the contents. From this example, you might conclude that super somehow returns the base class of a method's class, and that you can then invoke methods on the base class part of an object. This is only partly true. It's hard to sum up what super does in a single sentence, but here's an attempt. Given a method resolution order and a class C in that MRO, super gives you an object which resolves methods using only the part of the MRO which comes after C. In other words, super doesn't work with the base classes of a class, but instead it works on the MRO of the type of the object on which a method was originally invoked. The distinction is subtle but very important, and as we'll see, it resolves the mystery of how SortedIntList works. Super can be called in several forms, but all of them return a so‑called super proxy object. You can request any method on a super proxy, and it will resolve the name to the correct method implementation for you, if such a method exists. In other words, super searches through an object's inheritance graph for the correct implementation of a method, given a particular context. Let's see what that means and how it does that. When you call super, Python provides it with two important arguments. The first argument is the class of the method on which super's being invoked. So, for example, when our IntList initialize calls super, the proxy is given a reference to the IntList class object as an argument. The second argument is an object from which to derive an MRO. How this MRO is determined, it depends on what kind of method you're in, and we'll look at that in a moment. For now, just remember that a super proxy uses these arguments to resolve names. It's also important to note that the class argument must be a member of the MRO that's used. If you remember the description I gave as super a few moments ago, you can probably guess how super uses these arguments to resolve names. When you construct a super proxy and use the dot operator to look up a name, the proxy first looks in its MRO argument for the class argument. It then looks at every class after that point in the MRO for one that has a method with the requested name. The super proxy then uses the first match it finds. By far, the most common use of super in practice is inside instance methods. When a super proxy is created in an instance method, the first argument it gets is the class defining the method in which super is being called. The second argument is the method's self argument. To resolve names, super uses the MRO of the type of the self argument. Since such instance‑bound proxies have access to an actual instance of a class, as opposed to just the class object, we can use them to call instance methods, as well as class methods and static methods. To explore instance‑bound super proxies, let's modify the initializer of our IntList class to store and print the super proxy before using it to call dunder init. Now, if we construct a SortedIntList, we see some more details about the super proxy that we're using This output says that we've printed an object of type super, and the two arguments it received are the IntList class and an instance of SortedIntList. So to resolve method names, super is going to first find the MRO for SortedIntList. It will then find IntLst in that MRO and use everything after that point to resolve names. Let's see if we can reason through what this is doing more concretely. First, let's look at the MRO for the type of the SortedIntList instance. It's type, of course, is SortedIntList, so we need to look at the MRO for SortedIntList. As expected, this contains a SortedIntList, followed by IntList, SortedList, SimpleList, and finally, object. With this in mind, the super name resolution algorithm says to find the location of the first object, again, the IntList class object, in that MRO, and use what comes after that for name resolution. IntList is the second element in the MRO, so our super proxy is going to use SortedList, SimpleList, and object, in that order for name resolution. Now that we know what classes our super will use for name resolution, we can easily predict how the call to super dunder init will resolve. The first class in that sequence with a dunder init is SortedList, so that's what our super should end up calling. We can verify that by simply printing the method that it provides us. Now, if we construct a new SortedIntList, we see that indeed, our call to super dunder init in the IntList initializer is resolving to the initializer for SortedList. This may strike you as surprising. After all, the implementation of IntList makes no mention of SortedList. Yet IntList is able to delegate to SortedList through super. This works because super uses the full MRO of whatever self refers to. It's not limited to information about the defining class. This is a fairly deep and, we think, somewhat fascinating result, and it's one that we'll return to in a bit. The super proxy we looked at in the last section was instance bound. That is, it got the MRO it used for name resolution by first finding the type of an instance, normally the self argument to a method. Generally speaking, a super used in an instance method will be instance bound. What happens, however, if you try to use super in a class method? In that case, we don't have an instance to work with, but we do have a class object, specifically, the first argument to the class method. In this situation, you can still use super, but instead of looking for the MRO on the type of an instance, super simply uses the MRO of the class method's first argument, the class argument. Since our SortedIntList code doesn't have any class methods, we'll create a few simple classes here to help us explore this concept. We'll first define the class Animal with a class method description that returns a very rudimentary description. We'll then create Bird, a subclass of Animal that augments Animal's description with some further information. (Typing) Notice that Bird uses super in its override of the class method description. Finally, we'll create Flamingo, a subclass of Bird that provides an even more featureful description. (Typing) We can see that these behave as you probably expect. Animal gives a pretty bland description of itself, while Bird reports that it has wings, and finally, Flamingo shamelessly flaunts its bright plumage. Much like we did in the last section, let's modify Bird's description method to print some information about its super proxy. Now if we ask for Flamingo's description, we see the arguments used by the super in Bird.description. First, it's using the Bird class because that's the class in which the method is defined. Second, it's using the Flamingo class object because that's the value of the first argument to the class method. Similar to the instance‑bound case, super will find the location of the Bird class in the MRO of Flamingo, using everything after that to resolve methods. We can see that the MRO of Flamingo is Flamingo itself, followed by Bird, and Animal, with object at the end. Taking everything after Bird in that MRO leaves us with just Animal and object, so if we modify Bird's description method one more time, we won't be at all surprised to see that the call to super.description is resolving to the implementation of description on Animal. In the end, the only real difference between instance‑bound and class‑bound super proxies is that the former gets its MRO by looking at the type of the first argument to the method, while the latter looks at the MRO of the argument itself. As with many things in Python, while it's interesting and perhaps enlightening to understand how super works, you won't generally need to think about these details. Super will behave intuitively, without you needing to concern yourself with method resolution order or anything like that. We'd also like to briefly mention that it's possible to explicitly pass arguments to super. While this isn't commonly used in practice, it's a nice example of the explicit‑is‑better‑than‑implicit aspiration from the Zen of Python. When you pass two arguments to super, they're treated just like the implicit arguments we discussed earlier. The first argument is the class that will be used to trim the MRO, and the second argument will provide the MRO. For example, if we pass IntList and an instance of SortedIntList to super, it will resolve the name add to SortedList.add. Concerningly, this allows us to bypass IntList's validation, happily inserting non‑int objects into our SortedIntList. This is not the kind of behavior you normally want, so should you ever decide to pass arguments to super, do so with great care.

Resolving the Mystery
So let's do a quick review of what super does. Given a class and an MRO that contains that class, super takes everything in the MRO after the class and uses that as the new MRO for resulting methods. This is all bundled up into proxy objects, which are returned from the super call. Given that, let's see if we can resolve the apparent mystery of how SortedIntList works. Remember that SortedList and IntList were developed without referencing one another. Yet when they're combined in a subclass both of their constraints are still properly maintained. The key to how this works is that both SortedList and IntList use super to defer to their base class. But as we now know, super doesn't just let us access base classes, but rather it lets us access the complete Method Resolution Order for a class. So when SortedList and IntList are both used as base classes for SortedIntList the MRO for SortedIntList contains both of them. A call to add on a SortedIntList resolves to a call to IntList.add, which itself calls super. The super call in IntList.add uses the full MRO for a SortedIntList, meaning that rather than resolving to SimpleList.add, as we might naively expect, it actually resolves to SortedList.add. This is how SortedIntList maintains two constraints without having to manually combine them. This is a fairly deep result, and if you understand how SortedIntList works then you have a good grasp on super and method resolution order in Python. If you're still unsure about these concepts, review this module and experiment on your own until you do. Finally, let's finish this module by looking at the core of Pythons object model, the class called, fittingly enough, object. You saw object earlier in this module when we looked at the MROs for various classes. For example, it shows up in the MRO for IntList, just as it does for SortedIntList, or indeed for built‑in classes like list and int. The fact is that object is the ultimate base class for every class in Python. At the root of every inheritance graph you'll find object, and that's why it shows up in the Method Resolution Order. If you define a class with no base class you actually get object as the base automatically. You can see this by looking at the __bases__ member of a simple example class like this. What does object actually do? We won't get into the details of everything it does or of how it does it, but it's good to have some idea of the role that object plays in Python. First, let's just see what attributes object has. All of these are dunder functions, so clearly object is doing significant work to tie into Python's implementation details. For example, the __eq__, __ge__, __gt__, __le__, __lt__, and __ne__ methods are all hooks into Python's comparison operators. The __str__ and __repr__ methods, of course, tie into the str and repr functions. And object provides the default implementations of these methods. More importantly, object provides the mechanisms for basic attribute lookup and management. Methods like __getattribute__, __setattr__, and __delattr__ form the foundation on which Python objects expose attributes to callers. For the most part, you don't need to worry about object or understand much about how it works, but it is useful to know that it exists and that it's part of every class in Python. As you become a more expert Pythonista, you may eventually find that you need to know the details of object, so keep it in the back of your mind as you progress.

Summary
One of the aspects of Python that differentiates it from nominally typed languages like C++ and Java is that, for the most part, the specific type name of an object does not determine if it can be used in a given context. Rather, Python uses duck typing where an object's fitness for use is only determined at the time it's actually used, and exceptions are raised when an object doesn't have the necessary attributes to fulfill a request. Functions are defined without specifying type names on their arguments, and you can pass objects of any type to any function. Likewise, you can try to call any method you want on any object, and Python won't complain until runtime. One important result of this dynamic type system has to do with how inheritance is used in Python versus how it's used in nominally typed languages. With static nominal typing, if you want to pass an object to a function you need to make sure that the object is of the type expected by the function. As a result, you very often end up creating specific interfaces in base classes for specific uses, and the need to satisfy the type system becomes a significant, and sometimes the most significant, element in your development process. In Python, since there is no static type system to satisfy, inheritance isn't generally needed for the purposes of bestowing an object with a particular type. Rather, inheritance is best used as a way to share implementation. That is, inheritance in Python is a convenient way to reuse code, much more than it is a way to construct type hierarchies. Let's review what we've covered in this module. You declare multiple base classes with a comma‑separated list of class names in parentheses after a class's name in a class definition. A class can have as many base classes as you want. It's often best to explicitly call the base class initializer from a subclass's initializer. If a multiply inheriting class defines no initializer, Python will automatically call the initializer of its first base class on construction. If a class with a single base class doesn't define an initializer, the base class's initializer will be called automatically on construction. __bases__ is a tuple of types on a base class which defines the base classes for the class. __bases__ is in the same order as the class definition. __bases__ is populated for both single and multiple inheritance. Method resolution order, or MRO for short, defines the order in which Python will search an inheritance graph for methods. MRO is stored as a tuple of types on the __mro__ attribute of a class. To resolve a method, Python uses the first entry in a class's MRO which has the requested method. MRO is dependent on base class declaration order. MRO is calculated by Python using the C3 algorithm, which preserves base class declaration order and puts the subclasses before base classes. It is possible to specify an inconsistent base class ordering, in which case Python will raise a type error when the class definition is reached. Super operates by using the elements in an MRO that come after some specified type. Super returns a proxy object which forwards calls to the correct objects. A super proxy takes the MRO of its second argument or the type of its second argument, finds the first argument in that MRO, and uses everything after it in the MRO for method resolution. Since class‑bound proxies aren't bound to an instance, you can't directly call instance methods that they resolve for you. Inappropriate use of super can violate some design constraints. Since super works on MROs and not just the class's base classes, classes can be designed to cooperate without a priori knowledge of one another. The class object is at the core of Python's object model. Object is the ultimate base class for all other classes in Python. If you don't specify a base class for a class, Python automatically uses object as the base. Object provides default implementations of many common Python methods. Object implements the core attribute lookup and management functionality in Python. Inheritance in Python is best used as a way to share implementation. In the next module of Core Python: Classes and Object‑oriented Programming, we'll look at class decorators, a way to transform or augment classes without modifying their definitions directly. Thanks for watching, and we'll see you in the next module.

Class Decorators
Overview
We've used several function decorators so far in this course, such as static method and property, but it's not only functions which can be decorated, classes can too. In this module, we'll explore class decorators by building a few from scratch. Later in this course, we'll be looking at off‑the‑shelf class decorators from the Python Standard Library, so you'll be well prepared when we reach that point. Class decorators allow us to programmatically transform class definitions in a closely analogous way to have function decorators allow us to programmatically transform functions. Looked at this way, we can see that decorators are an important metaprogramming tool in Python, which is to say, they are tools which help programs write programs. Class decorators are capable of meeting many needs for which you might otherwise need to become familiar with metaclasses. We don't cover metaclasses in this intermediate‑level course. Look for our other Python courses here on Pluralsight which cover advanced Python topics. It's worth bearing in mind that anything that can be achieved with a class decorator can also be achieved with a metaclass, although the reverse is not true. In other words, class decorators are less powerful than metaclasses, although they are much easier to understand, and so should be preferred whenever the desired effect can be achieved with either a metaclass or a decorator. To get the most out of the material in this module, some familiarity with introspection could also be helpful. Elsewhere in the learning path, our course, Core Python Introspection, contains the necessary details, and much more. Recall that decorators are functions which accept one function as an argument and return another object, which is usually a wrapper around the original function which modifies its behavior. If you need to review the details, take a look at our course, Core Python: Functions and Functional Programming, earlier in the Core Python learning path. In any case, here's a brief refresher. Here we show a regular function which is bound by the def statement to f, and then processed by a function decorator, which creates a wrapper function object which refers back to the original function. Finally, application of the decorator re‑binds the name f to the wrapper. Class decorators work much the same way. In fact, we can use essentially the same diagram and change the names. Here we show a regular class which is bound by the class statement to the name C, and then processed by a class decorator, which creates a wrapper class which refers back to the original class. Finally, application of the decorator re‑binds the name C to the wrapper. A variant on this scheme, which is more commonly seen with class decorators than with function decorators, is to modify the decorated object in place rather than wrap it and return the wrapper. This is principally because classes provide much more opportunity for such in‑place modification than simple functions. Here we show a regular class which is bound by the class statement to the name C and then processed by a class decorator, which modifies the class object in place and then returns it. Finally, application of the decorator re‑binds the name C to the returned object, which has no effect, as it's the class object we first started with. With the theory understood, let's fire up a Python development environment and get to work implementing class decorators from scratch.

Can We Synthesize a Method?
To demonstrate class decorators, we're going to need a class to decorate. We'll use a simple Location class, which aggregates a place name, like Helsinki, with a latitude and longitude position like those we encountered earlier in this course. This class has a simple initializer, which accepts the name and the location, the body of which assigns the two private by convention attributes, _name and _position. Earlier in this course, we entreated you to always define a __repr__ for your objects, particularly value objects such as location here, something that we've so far neglected to do. Let's go ahead and defined __repr__ following the convention that it should return a string which looks like a constructor call. We get the name of the class using the typename utility function we introduced earlier and use keywords for both arguments, name and position, and their representation. While we're here, and for good measure, we'll implement __str__ as well, which will return just the name of the location. To support our example, we'll also instantiate five global location objects representing Hong Kong, Stokholm, Cape Town, Rotterdam, and Maracaibo. In the Python repl, we can try out our objects, getting the __repr__ version when we evaluate a position alone, and the __str__ version when we print one of our location objects. This is all well and good, but aren't we supposed to be looking at class decorators? Well, here's the challenge. Can we make a class decorator which can synthesize __repr__ method implementations for us so we don't have to write them by hand? We find __repr__ implementation syntactically fiddly to get right, but they're also highly formulaic. If we can codify that formula into a Python function, maybe we can save ourselves some work while accomplishing an important task. Our Location class has been carefully crafted so there is a correspondence between constructor arguments and properties. To be precise, for each initializer argument, other than self, a property is available that has the same name and returns the same type of object, and these are the names and values that need to appear in a well‑formed __repr__. So let's remove __repr__ and see if we can persuade the computer to make it for us.

Making a Class Decorator
We'll set out with a bold statement of intent by decorating location with our proposed class decorator, which we'll call auto_repr. We saw earlier that class decorators must accept a class object and return a class object. We can make the simplest possible class decorator by making auto_repr into what's called an identity function, a function which returns its argument, which we call cls to avoid a name clash with the class keyword. This code would work, but wouldn't do anything interesting, so let's augment it a bit by printing some details about the class being decorated, cls. We'll print a message announcing that we're decorating a class with auto_repr, and then request the members of that class using the built‑in vars function, which returns a mapping, a dictionary‑like object, from member names to member objects. We'll print out each name and member with a for loop. Now we have something interesting enough to try at the REPL, form location import everything. The messages are printed as the module is importing. This tells us something important about when class decorators are applied. They're applied when the decorated class is first being defined, and that happens when the module containing the class definition is first imported. Modules in Python are singletons, which is to say that each module only exists once in the memory of a given process, so importing a second time has no effect. In amongst the messages, we can find our initializer, __init__; our two properties, name and position; and our definition of __str__. The other special attributes expose some of the inner workings of Python. Our mission here is to get a custom definition of __repr__ into the decorated class, but to do that a few conditions must be met. Let's work through them. First of all, our class should not already have a __repr__. We can detect that case by looking up the name __repr__ in the members mapping, raising a TypeError if a member with that name is already present with a helpful error message. Second, our class must define its own initializer. The members mapping doesn't include inherited members, so we can check to see if __init__ is present, bailing out with an exception if it isn't. Again, we provide a helpful message to the TypeError constructor. The next check we need to do is a bit tricky. We need to verify that for every argument of __init__ beyond self, there exists a property with the same name. We can get hold of the argument list for __init__ by passing a reference to the __init__ method to the signature function of the standard library inspect module. This returns a special signature object which we call sig, from which we can get the parameter names. Note the syntax here. We're not calling __init__ here, we're passing the method itself to another function. We want all the parameter names except the first, which is self. We'll convert the signature parameters collection to a list so we can slice it, and then slice all but the first item, that is everything from index 1 to the end. We've written quite a bit of code here without testing, so let's prepare to try it at the REPL to verify we're on the right track. We'll print out the parameter names we've collected from __init__. Back at the REPL, importing our module is sufficient to see what's going on. We are indeed on the right track, having successfully obtained the two parameter names, name and position. Now we get to the tricky bit. We need to show that for every __init__ parameter name there exists a property with the same name. We'll write out an expression piece by piece. Given a parameter name, here called name, this expression attempts to get the object corresponding to that name from the members mapping. If there is no entry matching name, the call to get returns None. We then check the type of the results of this lookup against property. It turns out that the built‑in property decorator is also the property object that the property decorator produces. What this expression does is evaluate to true if the object associated with name is a property, rather than, say, a regular method. We need to perform this isInstance check for every parameter of __init__, so we'll turn this into a generator expression which evaluates the aforementioned check for each parameter name. This generator expression evaluates to a series of Boolean values, but we need to ensure that they're all true. We could use the built‑in function all for this. If they're not all true, we need to raise a TypeError with a helpful message. This message could be even more helpful listing the mismatches, but we'll leave that as an exercise for the interested student. If this check passes, we're in good shape and we can go ahead and synthesize a repr function for the class we're decorating. Let's build up our synthesized repr from scratch. We'll define it as a local function here within the class decorator, so we can close over useful variables we have already defined, such as parameter names. Let's start with something very simple. We're going to be patching this function into the class we're decorating as a method, so it has to accept self just like the regular __repr__. We know that we need to follow the convention of making the return string look like a constructor, so in the template we have placeholders for the typename and for the argument list. We are going to use the format method of strings to make these substitutions, rather than using an f string, because of the complexity of the expressions involved. For the typename, we'll pass self to our typename utility function. You might be tempted to get the typename from the class we're decorating, cls, but we want __repr__ to report the runtime dynamic type of self, not the static type class on which __repr__ is defined. We covered this important distinction earlier in this course. For the argument list, we need to build a comma‑separated list of name value pairs. We'll use the join method of str to intercalate the commas, and another call to format to generate age name value pair. We'll use the getattr function to retrieve the property value from the self instance, and loop over each parameter name using a generator expression. Notice that we've been careful to format using the repr of the property value. We need to use repr to ensure our resulting string looks like source code. There's one more thing we need to do before we can take our class decorator for another spin. We need to plug our synthesized repr function into the class being decorated as __repr__. We do this using a call to the built‑in function setattr, which accepts an object on which to set the attribute, in this case the class object we're decorating, cls; the name of the attribute to set, __repr__; and the value to which it should be set, in this case, our synthesized repr function. Our class decorator already returns a class object, so let's tidy up by removing the print statements which assisted us during development, and then we're good to go. Let's bring up a new REPL session and import our module. At this point, our new class decorator, auto_repr, has already being applied. To see whether it worked, we can evaluate one of our pre‑constructed location objects at the REPL, hong_kong. Excellent, it works. As you can see, to get the most out of class decorators you need to be comfortable with using the various tools Python gives us for introspecting and manipulating classes. With one decorator under our belt, let's crack on and make another.

Class Decorator Factories
Let's talk about class decorator factories. Now we've built one class decorator, we can confidently step forward to build a second. We'll start this section by introducing two new pieces of code before progressing to write the class decorator. The first class we'll see is called Itinerary and it manages a list of locations on a journey. Let's review each part while experimenting at the REPL. Itinerary has an initializer, which accepts an iterable series of locations from which it builds a list to be bound to the locations instance attribute. This list of locations is the fundamental data structure of an itinerary. We also have a named constructor from_locations. This is a convenience function which accept any number of locations as arguments and forwards the arg's tuple to the main constructor and hence the initializer. Let's instantiate an itinerary at the REPL using this named constructor. Trip is an itinerary built from locations Maracaibo, Rotterdam and Stockholm. Trip has the default and barely useful __repr__, but it does have a nice __str__, which prints out a list of locations one per line. Next, we have some read‑only properties. We can return a sequence of locations with the locations property. Notice that the property returns an immutable copy of the internal mutable list to prevent the internal data being modified through the read‑only property. We then have two more read‑only properties, origin and destination, which return the beginning and end locations of the trip, respectively. Next, we have three methods which modify the internal state of itinerary. We can add a location to the end of the journey. Here we use it twice to add Cape Town and then Hong Kong. Now our journey has five locations in total, and we can remove a location from the journey by name. Let's remove Stockholm from the itinerary, leaving us with four locations. Another mutating method allows us to truncate the journey at a particular location, removing all subsequent stops. Let's end our itinerary at Rotterdam. Now we're down to just Maracaibo and Rotterdam. Now we'll introduce a function decorator. We know you came here for class decorators, but don't worry we'll get there. Enjoy the buildup. In fact, it's not just a function decorator, it's a function decorator factory called postcondition. Postcondition accepts a predicate function, a function that returns true or false and builds a decorator around it, here called function_decorator. In turn, the function decorator builds a wrapper around the function being decorated, f, which executes f and then checks that the postcondition(predicate) function holds true before returning the results. If the predicate function fails a runtime error exception is raised with a helpful message. This is a pretty involved piece of code, and if you need to revise function decorator factories be sure to check out our course Core Python: Functions and Functional Programming. To make use of it, we need a predicate function that pertains to itineraries. Here's one that checks that an itinerary has at least two locations. Don't be concerned about the fact we directly access private by convention data. This predicate we'll be used so closely with itinerary it will effectively become part of it. Let's use our new function decorator factory to check this predicate on every mutating method of itinerary, add, remove, and truncate_at. A slightly more subtle case is that we can also apply this decorator to the initializer, __init__, to check that the constructor establishes the invariant of having at least two locations. Let's check it out interactively. Well, everything imports okay, which is a good sign. Let's try to create an itinerary with fewer than two locations, in this case just Maracaibo. The postcondition cannot be maintained so the constructor fails, preventing us from creating an invalid itinerary. Thankfully, we can create a trip with two locations, Maracaibo and Rotterdam, and can add locations, Cape Town and Stockholm, freely. When we remove too many locations the postcondition check fires again. If we truncate our trip at the outset at Maracaibo we get another postcondition failure. This is all very well, but having to figure out which methods might mutate the data and so benefit from the postcondition is onerous and that code quickly gets littered with function decorators. What we'd like is to have a single class decorator and have it supply all the individual method decorators for us. In fact, we're going to need a class decorator factory because we want to be able to parameterize the decorator with the postcondition predicate. We'll call our predicate‑accepting decorator factory invariant. The class decorator factory needs to create a function decorator with which to decorate each method. We can do this by calling the function decorator factory postcondition and holding a reference to the returned decorator. Our class decorator factory will need to return a class decorator, and class decorators must accept the class being decorated as their only argument, cls. The class decorator will be modifying the class in place so it can return its argument. We'll take a copy of the mapping of the members of the class we're decorating into a list. We take a copy because we shouldn't modify a mapping while we're iterating over it, which we're about to do. For each member we'll use the isfunction method from inspect to check whether it is a function. It's tempting to use ismethod, but in Python's internal model a member function doesn't become a method until it's bound to an instance. We have no instance, only a class, so Python considers these functions. If the member is a function we decorate it with our function decorator. Remember, decorators are just regular functions which transform other functions and we can call them to transform a function without using the at symbol syntax. Finally, we reset the member in the class being decorated to the decorated function, replacing the un‑decorated function, which was previously bound to the same name. Now we can try applying our decorator to the itinerary class with @invariant passing are predicate. And we can remove the individual function decorators from the methods. There's a lot going on here and this code is pretty dense. Let's see if it works. The class invariant check should prevent us from creating an itinerary with only one stop. Let's try to make a trip with just Rotterdam. This fails. Good. The postcondition, at_least_two_locations, could not be maintained when there was only one location, but it does correctly allow us to create an itinerary with two or more stops, Rotterdam and Stockholm here. Our class should also tell us if the invariant is violated while modifying the trip. Let's remove Stockholm. Good, another runtime error. It's important to understand that our decorator only detects and signals invariant violations, it doesn't prevent them or roll back the breaking change. We can peek inside the trip object and look at the _locations attributes directly to see this. It's an interesting exercise to try and implement transactional behavior, a so‑called strong exception guarantee. But that's an advanced technique beyond the scope of this intermediate‑level course. Recall that multiple function decorators can be applied simultaneously. Here's another predicate which efficiently checks that there are no locations that occur more than once in an itinerary. We can apply that too using a second application of the invariant decorator. We can add our auto_repr decorator too to plug an important gap in our class implementation. Now we get the benefits of a useful __repr__ when our new no_duplicates invariant cannot be maintained when we tried to create a trip from Rotterdam to Rotterdam. The runtime error tells us which postcondition failed and gives us the full state of the itinerary object at the point that it failed, containing two instances of Rotterdam. Everything fits together very nicely. These class decorators compose together well, and software components which compose seamlessly in this way, are to be valued.

Summary
Let's summarize some of the key points about class decorators. In the same way that function decorators can be used to transform functions, class decorators can be used to transform classes. Whereas function decorators accept a single function object as their only argument, class decorators accept a single class object, conventionally named cls, as their only argument. Class decorators should return a class object. This is often the same class object accepted as the argument, with the decorator manipulating the class object in place. Class decorators can do much of what metaclasses can be used for, but they're easier to understand and simpler to program. To parameterize a class decorator, create a class decorator factory, a function which returns a class decorator. Multiple class decorators can be applied to a single class, and well‑designed class decorators compose well in this way. Class decorators provide a powerful metaprogramming technique in a fairly accessible way. We don't always need to write our own class decorators, though. Some interesting class decorators are included in the Python standard library, and we'll be introducing one of them in the next module.

Data Classes
Data Classes
Sometimes you need a simple object which bundles together or aggregates some other objects into a compound data type, which doesn't have much or any interesting behavior of its own. Python's data classes are designed to meet this need. In this module, we'll introduce data classes, show how to define them, and discuss the context in which they're useful while being mindful of the situations where they could be inappropriate. To start, let's look at a motivating example, the Location class we introduced in the previous module on class decorators. Here it is, complete with our @auto_repr class decorator, which synthesizes a __repr__ implementation for us based on the predictable structure of the initializer argument list and corresponding property getters. There isn't much to location, it's just a compound data type of a couple of read‑only sub‑objects, a name, and a position. Yet even without @auto_repr decorator, it requires some 17 lines of code to define it, and it's still missing some important features. It's not equality comparable, so we can't compare two locations for value equality. Here, we define objects a and b with equivalent values of name and position, but they compare false with the equals operator. And while it's hashable, it's not hashable in a useful way. Objects with equivalent values hash to different hash codes, which means we can't use it in collections like set or dict, which are internally based on hash tables, and so require meaningfully hashable elements. We could go ahead and implement the special methods required to support equality comparison and hashability, __eq__ and __hash__, but that's another seven lines of code, and again, it's all quite predictable, formulaic, and could be derived automatically by, say, a class decorator.

Defining Data Classes
This is where data classes come in. Let's evolve our Location class into a data class using the @dataclass decorator from the Python Standard Library Data Class's module. The Location class is decorated by the @dataclass class decorator and the body of the class contains what looked like two class attributes. Both of these attributes have type annotations. Type annotations are optional in Python, but in this class they're necessary so that the @dataclass decorator can detect the class attributes it needs to process. This looks very different from the other class definitions we've seen so far, so let's unpack what's going on here. What the class decorator will do is collect up these class attributes and use them to synthesize implementations of a __init__, which accepts arguments with these names, and a __repr__, similar to the one we synthesized ourselves earlier. We can create an instance of our Location data class in exactly the same way as we could before, and it's repr is identical too. If we want @dataclass to make Location equality comparable, additional fine‑grained control over which methods are generated is provided by a series of optional arguments we can pass to the @dataclass decorator. Setting eq to true enables synthesis of a __eq__ method. Other parameters, like init, repr, and order, control whether __init__, __repr__, and the rich comparison operators which support less than, greater than, and so on are implemented. Notice that @dataclass can be used directly as a decorator, or, if parameters are needed, as a decorator factory. With equality, if not liberty and fraternity enabled, we can confirm that Paris is indeed the capital of France.

Hash and Hashability
Hashing in Python is fraught with complexity and hashing of data classes doubly so. The difficulty is that Python has limited capabilities to convey the notion of immutability, yet hash‑based collections can only be used with immutable objects. To further complicate things, there are rules about the consistency of results obtained from dunder eq and dunder hash. Essentially, if they have the same hash code, they might be equal, but if they're equal, they must have the same hash code. We're not going to get into the weeds of the rules about the unsafe hash argument to the data class decorator and the complex variety of circumstances around where the data class will or will not generate dunder hash for you, and whether the dunder hash it generates will enable or prohibit hashing. Without hashing enabled though, you won't be able to use your data class instances with hash‑based containers such as set. We can't create this set of cities, because we get the type error, unhashable type location. What we are going to do is to give you our opinionated recommendation, which is that data classes are best used to represent immutable value objects. This implies two things. The first recommendation is that you only place immutable objects in data classes. So basic types like ints, floats, and strings are fine, as are specifically designed immutable types like our position class. In fact, our position class will also need an implementation of dunder hash to make it hashable, a change we've included in the example code. The second recommendation is that your data class be declared frozen, which is Python speak for immutable. By passing frozen equals true, there's an argument to the data class. If you enable equality comparisons, and immutability, the data class decorator will make your objects hashable and so usable in collections like set and frozen set, and as dictionary keys. Now we can create a set containing Hong Kong, Stockholm, Cape Town, Rotterdam, and Maracaibo without Python complaining about unhashable types.

Dataclass Invariants
What about establishing class invariants? One of the key arguments in favor of using classes to hold data over dump data structures like a dictionary is that they allow us to enforce rules about the contained data. We've always had the choice of whether to use simple collections like dictionaries or full‑blown classes to aggregate simple data types into more complex ones. Data classes lie in the middle ground. How can we enforce simple invariants on them? For example, how can we ensure that the name field of our location is not an empty string? How can we prevent this? We could override dunder init, but then we would be beginning down the road of re‑implementing code that data classes generated for us, and we would rapidly get into diminishing returns, a point we'll return to later. Fortunately, the generated dunder init will call a data class‑specific special method called dunder post‑init. At the point dunder post‑init is called, all instance attributes will have been initialized, so it doesn't take any arguments beyond self, as dunder post‑init can get hold of everything it needs through self. Dunder post‑init is a good place to perform validation on data class instance construction. We allowed a guard clause to post‑init, which checks that the name attribute is not the empty string, and if it is, raise a value error with a message that location name cannot be empty. Trying to create our null_island now with an empty name causes the value error to be raised, preventing the invalid object being created. This brings us back to why we think immutability should be your default for most data classes, even though it isn't data classes built in default. Consider what would happen if we allowed location to be mutable again. While we can still have dunder post‑init establish the invariant on construction, we can no longer maintain the invariant on attribute access. Classes without invariants aren't much more than dictionaries, and so the marginal value of the data class mechanism is eroded. To maintain this invariant, we would need to define a property setter, and in the first module of this course, we saw some of the difficulties in overriding setters, particularly when you're not in charge of the base class implementation. At this point, we usually end up promoting our data classes to a regular full class where we can define property setters and other mutating methods. Given that most of the benefits of object‑oriented programming spring from encapsulation of data, enforcement of class invariants, grouping behavior with data, and so on, we have found that many data classes in our code have a rather short life and are soon promoted to regular classes with important invariants and useful behaviors where we can tell objects what to do rather than query their internal state. Tell, don't ask. That said, simple, lightweight, compound data types clearly have a role in programming and data classes meet that need well. For these reasons and others, we recommend keeping your data classes simple. Avoid combining them with inheritance, stick to the basic options, and exhibit a strong preference for immutability. There are more details to data classes, and you can consult the Python documentation to learn more. But we're inclined to say that if you need this detail, then there's a good chance that a data class is an inappropriate solution to the problem at hand.

Summary
Let's quickly summarize what we've learned about data classes. A data class is a simple class with data attributes and little behavior. The dataclass' module in the Python Standard Library provides a class‑decorator, which helps in declaring data classes. The decorator interprets type‑annotated class attributes as a specification for synthesized __init__ and __repr__ implementations. The dataclass decorator accepts optional parameters to control which methods are generated and can be instructed to produce the special methods which support equality and hashing. The generated __int__ method invokes __post_init__, which can be used to validate attribute values on construction. There are good reasons to strongly prefer immutable data classes, where each component attributes is itself an immutable type, and the frozen flag has been set to suppress setter generation. If you also set eq to make the class equality comparable, dataclass will make your objects hashable, so they can be used with hash table‑based containers like set and dict. Well done on completing Core Python: Classes and Object‑oriented Programming. Python is. at its heart, an object‑oriented language, and knowing how to use the class definition tools in Python can be the key to creating elegant, powerful designs. This course has given you a solid overview of the class definition tools provided by the core Python language, as well as the Standard Library, though it takes practice to discover the right concepts during code as classes and the best way to allocate concerns to different classes. We're still learning and getting better at this after decades of object‑oriented programming. One key piece of advice is to prefer a greater number of simpler classes, which collaborate to achieve some aim, rather than fewer, but more complex classes. With classes, smaller and more numerous is better than larger and fewer. Each class should do one thing and do it well. Look out for our other core Python courses here on Pluralsight, which build on the knowledge you've gained here, and which explain many of the other tools and abstractions provided by Python for building powerful programs. Remember to check out our collection of Python books, which covers these topics in written form. Specifically, you'll find these topics covered in the Python Journeymen, the second book in our trilogy. We'll be back with more content for the ever‑growing Python language and library. Please remember though that the most important characteristic of Python is that above all else, it's great fun to write Python software. Happy programming.